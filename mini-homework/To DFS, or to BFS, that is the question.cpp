#include <iostream>#include<algorithm>#include <vector>#include <deque>#include <queue>//reference:https://kopu.chat/2017/09/22/%E5%AF%A6%E4%BD%9Cgraph%E8%88%87dfs%E3%80%81bfs%E8%B5%B0%E8%A8%AA/using namespace std;bool cmp(int a, int b){	return a < b;}class GraphNode{	public:	  int id;	  deque<int> adjacency;	  int discovered;	  GraphNode(){}	  GraphNode(int id):id(id), discovered(0){}};deque<GraphNode> DFS_list, BFS_list;void DFS(int vertex){	  DFS_list[vertex-1].discovered = 1;	  cout << vertex << ' ';	  sort(DFS_list[vertex-1].adjacency.begin(), DFS_list[vertex-1].adjacency.end(), cmp);	  for(int i = 0; i < DFS_list[vertex-1].adjacency.size(); i++){		int next = DFS_list[vertex-1].adjacency[i];		if(DFS_list[next-1].discovered == 0){		  DFS(next);		}  }}void BFS(int start){	queue<int> q;	q.push(start);	BFS_list[start-1].discovered = 1;	int curr_id, adj_id;	vector<int> tmp;		while(!q.empty()){            int size = q.size();            while(size--){                int curr_id = q.front();				tmp.push_back(curr_id);                q.pop();                for(int i = 0; i < BFS_list[curr_id-1].adjacency.size(); i++){				  adj_id = BFS_list[curr_id-1].adjacency[i];				  if(BFS_list[adj_id-1].discovered == 0){					BFS_list[adj_id-1].discovered = 1;					q.push(adj_id);				  }				}            }			sort(tmp.begin(), tmp.end(), cmp);			for(auto it : tmp)				cout << it << ' ';			tmp.clear();        }}int main(){	int v1, v2;	int node_num, edge_num;	cin >> node_num >> edge_num;	for(int i = 1; i <= node_num; i++){		BFS_list.push_back(GraphNode(i));		DFS_list.push_back(GraphNode(i));	}	for(int j = 0; j < edge_num; j++){		cin >> v1 >> v2;		BFS_list[v1-1].adjacency.push_back(v2);		BFS_list[v2-1].adjacency.push_back(v1);		DFS_list[v1-1].adjacency.push_back(v2);		DFS_list[v2-1].adjacency.push_back(v1);	}	DFS(1);	cout << endl;	BFS(1);	}